# PHP App ② レビュー

## XSS(クロスサイトスクリプティング)

### XSSとはどんな攻撃か、また攻撃者にどんなメリットがあるか説明してください。
ユーザーのアクセス時に表示内容が生成される「動的Webページ」の脆弱性、もしくは脆弱性を利用したもので悪意のあるスクリプトを
Webページに埋め込む攻撃方法です。
スクリプトを他のユーザーのブラウザで実行させることでユーザーの個人情報やセッション情報を盗んだり、Webページの表示を改ざんしたりする。
XSSにはいくつかの種類があり、
1.保存型XSS(Stored XSS)
  悪意のあるスクリプトがデータベースやサーバーに保存され、他のユーザーがそのデータを表示するたびにスクリプトが実行される。
2.反射型XSS(Reflected XSS)
  攻撃者が悪意のあるリンクを生成し、そのリンクをクリックしたユーザーのブラウザにスクリプトが反射されて実行される。
3.DOM型XSS(DOM-based XSS)
  ブラウザ内のDOM操作によって、スクリプトがクライアントサイドで実行される。サーバーには依存せずクライアント側で直接悪意のある操作が行われる。

攻撃者のメリット
いくつか挙げられるが、
1.個人情報の窃取
  cookieやセッションID、パスワードやクレジットカード情報などの盗難や取得ができる。
  これにより、アカウントに不正ログインをして使用したり、闇市などで売却したりもできる
2.セッションハイジャック
  ユーザーのセッション情報を盗むことで被害者になりすましてウェブサービスにアクセスできる。
  オンラインショッピング等での金銭的被害をもたらすことができる。
3.サイトの改ざん
　悪意のあるスクリプトによってサイトの表示内容を改ざんすることができる。
　ユーザーに対して偽の情報を見せたり、悪意のあるサイトへリダイレクトさせることも可能になる。
4.フィッシング攻撃
　ユーザーに偽のログイン画面やフォームを表示させ、そこに個人情報（ユーザー名、パスワード、クレジットカード情報など）を取得することができる。
5.ウェブアプリケーションの管理者権限を奪取
　管理者ユーザーがXSS攻撃を受けると、攻撃者は管理者権限を奪取することができ、これによってサイトの全体を乗っ取ることができる。
6.マルウェアの配布
　悪意のあるスクリプトやファイルをユーザーに自動的にダウンロードさせたり、ブラウザを通してマルウェアに感染させることができる。7
7.サイトの評判を落とす
　サイトがXSSによって攻撃されることでユーザーがサイトが脆弱だと認識をし、すると利用者が減っていき運営者に対する信頼も低下していく。

### `htmlspecialchars()`を`e()`として定義しなおすメリットを説明してください。
1.コードの可読性の向上
　関数名が長く冗長になりやすい。短く簡潔なものにすることでコード全体がすっきりし、読みやすくなり視覚的に分かりやすくなる。
2.一貫性の向上
　プロジェクト全体で一貫したエスケープ処理を実施できるようになる。他のエスケープ処理が必要になった場合e()の定義を変更するだけで全体に適用することができるため、保守性が向上する。
3.将来の拡張が容易になる（メンテナンス性の向上）
　将来より高度なサニタイズやフィルタリングが必要になった場合、e()関数の中で処理を変更すれば良いためコードの修正範囲が最小限で済む。
　変更箇所が一点に集中するためメンテナンスや拡張が容易になる。

### `htmlspecialchars()`を使うことでなぜXSSが防げるのか説明してください。
　XSS攻撃は攻撃者がフォームやURLのクエリパラメータなどに悪意のあるスクリプトコードを含めて送信し、それが表示されることでブラウザがそのスクリプトを実行してしまうこと。
　htmlspecialchars()を使用することで
  ユーザーが入力したデータの中に含まれるHTMLやスクリプトコードを無害な文字に変換し
  攻撃者の悪意のあるスクリプトが実行されることがなく単なるテキストとして表示されるためXSS攻撃を防ぐことができる。


## CSRF(クロスサイトリクエストフォージェリ)

### CSRFとはどんな攻撃か、また攻撃者にどんなメリットがあるか説明してください。
ユーザーが認証されたセッションを使って不特定多数の人に対して意図しないリクエストを送信させる攻撃。
代表的な方法として自分が作ったサイトにフォームを設置して送信ボタンを押させる方法。
Amazonなどの既存のサービスと全く同じ見た目のサイトを作成し、不特定多数のユーザーがそのサイトにくることで攻撃をすすことができる。

CSRFのメリット
1.不正な操作の実行
　・金銭の送金：銀行から攻撃者の口座に送金させる
　・アカウントの変更：パスワードやメールアドレスの変更を強制的に行うことで被害者のアカウントを乗っ取る。
　・データの削除：重要なデータを削除することで、ユーザーに損害を与える。
2.個人情報の取得
　ユーザーのアカウントを不正操作することで個人情報や機密情報を取得できる可能性がある。
　これによりフィッシングやなりすまし攻撃を行うための情報を取得
3.サイトの信用を落とす
　金融機関やオンラインサービスの場合、顧客の信用を損ねることになり結果的にサイトの利用者を減らすことができる
4.利用者の権限を悪用できる
　被害者が持つ権限を利用してより高いレベルの操作を行うことができる。
　被害者が管理者権限を持っている場合攻撃者はその権限を使ってシステムに対する不正アクセスを試みることができる。
5.フィッシング攻撃
　フィッシングサイトへの誘導や偽フォームからの情報収集などを行うことができる。


### SessionとCookieの違いを説明してください。

SessionとcookieはどちらもWebアプリケーションでユーザー情報を保存、管理するためのものですが、
Sessionはサーバー側で管理をされ、Cookieはブラウザ側で管理をされる。


Session
サーバー側で管理をし、ユーザーごとに一意のセッションIDが生成される。このIDはクッキーやURLパラメータを通じてユーザーのブラウザに送信される。
セッションはサーバーに保存されるためユーザーがブラウザを閉じたりセッションがタイムアウトするとデータは失われる。
サーバー側に保存をされるため保存できるデータ量が大きくユーザーの詳細な情報や一時的なデータを保存するのに適している。
セキュリティ面に関してはデータがユーザーの端末に直接保存されないためセキュリティリスクは少ないですが、セッションハイジャックには注意が必要になる。
また、有効期限はユーザーがログアウトするか、一定時間操作がない場合に自動的に終了する。

Cookie
ブラウザ側で管理をし、ユーザーの端末にデータが保持される。サーバーからの応答時にクッキーが作成され以降のリクエストで自動的に送信される。
クッキーはユーザーのブラウザに保存されるため、ユーザーがブラウザを閉じても保存されたデータは残る。
クッキーは保存できるデータ量が制限されている。（一般的には１つのクッキーに対して4KB程度）このため、設定やトラッキング情報など少量のデータを保存するのに適している。
セキュリティ面はユーザーの端末に保存されるため、XSSなどの攻撃によって盗まれてしまうリスクがある。
有効期限はクッキーは有効期限を設けることができ、期限が切れると自動的に削除される。永続的なクッキーはユーザーがブラウザを閉じても残る。

### `setToken()`が何をしているか説明してください。
　セキュリティ対策として使用されるトークンの生成や設定をする関数。CSRFの攻撃からアプリケーションを保護するために使用され悪意のある攻撃を防ぐことができる。
具体的な役割として
1.CSRFトークンの生成
　CSRF攻撃からアプリケーションを保護するためにランダムにトークンを生成する。このトークンはフォーム送信時に一緒に送信されることでリクエストが正当なものであることを確認する。
2.セッションの管理
　ユーザーのセッションに関連づけられセッションが有効である限り有効です。これによりユーザーのリクエストがユーザー本人からのリクエストであることを確認する。
3.トークンの保存
　ユーザーのセッションやデータベースに保存されることがある。これにより後からリクエストが送信された時、送信されたトークンと保存されたトークンを照合することができる。
4.トークンの取得
　生成されたトークンをフォームのhiddenフィールドやHTTPヘッダーとして出力するために使用されることがある。

### `checkToken()`が何をしているか説明してください。
 フォームやリクエストに含まれているトークンがサーバー側で生成・保存されたトークンと一致するかどうかを確認する。
 ユーザーから送信されたリクエストが正当なものかを確認することで不正な操作や攻撃を防ぐことができ、セキュリティを強化する。
 1.トークンの取得
 　POSTやGETなどのリクエストで送信されたトークンを取得する。
 2.セッション内のトークンとの照合
 　送信されたトークンがサーバー側のセッションやデータベースに保存されているトー　クンと一致するかを確認する。
 3.トークン一致の確認
 　送信されたトークンが保存されているトークンと一致しなければ不正な操作とみなさ　れ処理は中断する。
 4.エラー処理
  トークンが一致しない場合はエラーメッセージを表示するかリダイレクトを行うなどの処理がなされる。

### トークンを使うことでなぜCSRFが防げるのか説明してください。
　1.外部サイトからはトークンを送信することはできない
　攻撃者は悪意のあるサイトから被害者にリクエストを送信させることはできてもそのリクエストに正しいトークンを含めることはできない。
　トークンはサーバー側で生成され、セッションと連動して管理されるために攻撃者はその値を知ることはできない。
2.正規のフォームでしか有効なトークンは送れない
　トークンはページをロードした時にサーバーが生成しフォームに埋め込まれるためユーザーがそのページを使ってリクエストを送信した場合のみトークンは一致する。
　攻撃者がページ外からリクエストを送信しようと思っても正しいトークンを得ることはできないためリクエストは無効になる。

## SQLインジェクション

### SQLインジェクションとはどんな攻撃か、また攻撃者にどんなメリットがあるか説明してください。
　攻撃者側がアプリケーションのセキュリティ上の不備を意図的に利用し、アプリケーションが想定しないSQLを実行させることでデータベースシステムを不正に操作する攻撃方法。
　ユーザーからの入力データが適切に処理、検証されていない場合に発生する。
　SQLインジェクションは、データ漏洩やデータ改ざんや削除、管理者権限の取得、システムの破壊などの危険性がある。

　攻撃者のメリット
1.データの不正取得
　・個人情報(氏名、住所、電話番号など)
　・ユーザーの認証情報
　・クレジットカード情報などの金融データ
　・機密文書や社内情報などの非公開データ
　などの機密情報の漏洩
2.ユーザーのアカウントの乗っ取り
3.データの改ざん
4.データベースの破壊
5.バックエンドシステムの制御
6.経済的利益の獲得（ランサムウェア攻撃など）

### `->prepare()`の返り値と、またこのメソッドが何をしているか説明してください。
  prepare()の返り値はPDOStatementオブジェクトを返している。
  prepare()メソッドはSQLクエリをプリペアドステートメントとして準備する役割を果たしている。
  このメソッドは安全かつ効率的にSQLクエリを実行できるようにして特にSQLインジェクション攻撃から守るために重要です。

  prepare()メソッドがしていることとして
  1.SQLの準備
  　SQLを解析しクエリを実行実行するための準備を行うが実際にクエリは実行されない。
  　この段階でSQL文中に変数が直接含まれないためSQLインジェクションを防ぐことができる。
  2.プレースホルダーの設定
  　prepare()を使って準備したSQL文には変数の代わりにプレースホルダーが含まれる。
  　プレースホルダーは後で値をバインドするための場所をしめしている。例として:idなどが使われる。
  3.SQLの実行準備
　　クエリを実行する準備が整ったらbindValue()やbindparam()を使って具体的な値をプレースホルダーにバインドする。
　　値がバインドされた後にexecute()メソッドを呼び出して実際にクエリを実行する。

### `->bindValue()`が何をしているか説明してください。
　SQL文中のプレースホルダーに実際の値をバインドする役割をしています。
  1.プレースホルダーに値をバインドする
　 SQL文には直接値を埋め込まず、プレースホルダーを使う。bindValue()はそのプレースホルダーに実際の値を関連づける。
  2.データ型を指定する
  　bindValue()は第三引数で値のデータ型を指定することができる。
  　例えば、文字列を送る際はPDO::PARAM_STR,整数を送る際はPDO::PARAM_INTと指定する。

```PHP
$sql = 'UPDATE todos SET content = :todoText WHERE id = :id';
$stmt = $dbh->prepare($sql);
$stmt->bindValue(':todoText', $post['content'], PDO::PARAM_STR); // プレースホルダー ':todoText' に '$post['content']' の値を文字列としてバインド
$stmt->bindValue(':id', (int) $post['id'], PDO::PARAM_INT); // プレースホルダー ':id' に '$post['id']' の値を整数としてバインド
$stmt->execute(); // SQL文を実行
```
$stmt->bindValue(':todoText', $post['content'], PDO::PARAM_STR);
　SQL文の:todotextというプレースホルダーに$post['content'](例えば、新しい日記)という内容をバインドする。

$stmt->bindValue(':id', (int) $post['id'], PDO::PARAM_INT);
　SQL文の:idというプレースホルダーに$post['id']という値をバインドしている。

### 今回の対策でなぜSQLインジェクションが防げるのか説明してください。
　プレースホルダーとbindValue()を使用してユーザーの入力データを適切に処理しているため。
　
　1.プレースホルダーを使うことでユーザーからの入力がSQL文に直接挿入されず分離された状態でよりされる。
　　これによってSQL文がそのまま文字列として解釈されるリスクを避けられる。
  2.bindValue()はプレースホルダーに結びつけた値を安全な形式にエスケープしクエリの一部として実行する。
  　これによりユーザーが入力した内容がSQL文として誤解されないように保護される。
  例えば$post['content']に悪意のあるコードが含まれていてもエスケープ処理によって単なる文字列として扱われるため実行されない。
  3.データ型を指定することにより適切なデータ型で処理をされデータベースに対して意図しない操作が行われることを防ぐ。
  　例えば$post['id']に数値以外の不正なデータが入力されたとしてもPDO::PARAM_INTによって整数型にキャストされ不正な操作が防止される。

## バリデーション

### バリデーションの目的について説明してください。
　システムやアプリケーションで扱うデータが正しい形式や内容であるかどうかを確認して予期しない動作やセキュリティの脅威を防ぐこと。
　例えば郵便番号は「-」を抜いた状態で入力してほしい。SNSのアカウントには「-」「_」を使用できないようにする。必ず性別を選択してほしい。など
　入力された値が制限通りの内容になっているかどうかを確認をする処理。
具体的な目的として
1.データの正確性を保証
　ユーザーから入力されたデータや外部から取得したデータがシステムの指定する形式や値であることをチェックする。
　例えばメールアドレスの形式や電話番号の桁数などをチェックし不正なデータが処理されないようにする。
2.セキュリティの確保
　入力フィールドを使って不正なコードをシステムに送り込むことを防ぐ
3.システムの安定性の向上
　不正なデータがシステム内に入ることを防ぎ、安定性を保つことができる。

### `validate()`が何をしているか説明してください。
　ユーザーの入力や外部からのデータが指定された条件を満たしているかどうかを確認するために使用される。
1.入力データのチェック
　必須項目が入力をされているのか、数値が期待される場所に数値が入っているかメールアドレスの形式が正しい形式かをチェック
　不正なデータや期待されていないデータが送信されないようにすることが目的
2.未入力や不正データの検出
　必須フィールドが空かどうか、あるいは数値を入力してほしいのに文字列が入力されている場合などを検出してエラーを返すことができる。
3.エラー処理
　入力が不正であればエラーメッセージを生成し、エラーメッセージをユーザーに返すことで正しい入力を促します。

　

### `isset($post['content'])`はなぜ必要か、無い場合どうなるか説明してください。
  フォームデータの送信時にcontentが存在しているかどうかを確認してプログラムのエラーや意図しない動作を防いでアプリケーションの安定性とデータの整合性を保つため。
  
  1.$post配列の中にcontentというキーが存在するかをチェックできる。
  フォームが送信される時にcontentフィールドが欠落している場合もあるためその場合にはその処理を適切にスキップするかエラーメッセージを出すことができる。
  2.入力データのバリデーション
  ユーザーがフォームにデータを入力していない場合やフォームからデータが正しく送信されなかった場合に対応するためにフィールドの存在を確認する。
  これにより不正なデータが処理されるのを防ぎアプリケーションの整合性を保つことができる。
  3.入力データのバリデーション
  　ユーザーがフォームにデータを入力していない場合やフォームからデータが正しく送信されななかった場合に対応する時にフィールドの存在を確認する。

 ` isset($post['content'])`がない場合
未定義の変数へのアクセスが原因でエラーが発生し、アプリケーションの動作が不安定になったり意図しないデータベースの操作やセキュリティリスクが生じる可能性がある。
1.未定義インデックスエラー
フォームが送信された際にcontentフィールドが欠落してる場合、$post['content']にアクセスをすると「未定義インデックス」のエラーが発生し、
アプリケーションが予期せず停止する可能性がある。
2.意図しないデータの処理
　フィールドが存在しない場合変数$post['content']はNULLもしくは未定義のままになる。この状態でデータベース操作が行われると空の値がデータベースに登録されたり
　意図しないデータの更新が行われる可能性がある。

### `unsetError()`を実行しないとどうなるか説明してください。
unsetErrorを実行しないとエラーメッセージが不要に残り続けてしまいユーザーに誤った情報を提供し
ユーザーエクスペリエンスが低下をしたり、セッションデータが無駄に蓄積するなどの問題が発生する。

1.エラーメッセージが残る
　一度表示したエラーメッセージが次回リクエストやページの再読み込み時にも表示され続ける可能性がある。通常エラーメッセージは一時的に表示されるものですが、
　unsetError()を使わないとエラーメッセージがセッションや変数に残りユーザーに不必要に表示され続ける。
2.ユーザーエクスペリエンスの低下
　ユーザーが問題を修正して再度フォームを送信した際に過去のエラーメッセージが再び表示されることでユーザーがフォーム送信を再度失敗したと誤解をする可能性がある。
　これによりユーザーのエクスペリエンスが低下する。
3.エラーメッセージが正しく表示されない
　新しいリクエストがあった際に、前回のエラーが残っていると現在の状態に基づいたエラーメッセージではなく前回のエラーメッセージが表示されてしまう可能性がある。
　最新のエラーが正しくユーザーに伝わらず、誤解を招いてしまう。
4.メモリリークやセッションデータの蓄積
　不要なセッションが残り続けメモリリークやセッションデータの無駄な蓄積につながる。多くのユーザーが利用する場合サーバーリソースの消費を増やす要因になる。